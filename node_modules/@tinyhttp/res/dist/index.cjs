'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var send = require('@tinyhttp/send');
var cookie = require('@tinyhttp/cookie');
var cookieSignature = require('@tinyhttp/cookie-signature');
var mime = require('es-mime-types');
var req = require('@tinyhttp/req');
var esVary = require('es-vary');
var http = require('http');
var escapeHtml = require('escape-html');
var contentDisposition = require('@tinyhttp/content-disposition');
var path = require('path');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var escapeHtml__default = /*#__PURE__*/_interopDefaultLegacy(escapeHtml);

const setCookie = (req, res) => (name, value, options = {}) => {
    const secret = req.secret;
    const signed = options.signed || false;
    if (signed && !secret) {
        throw new Error('cookieParser("secret") required for signed cookies');
    }
    let val = typeof value === 'object' ? 'j:' + JSON.stringify(value) : String(value);
    if (signed) {
        val = 's:' + cookieSignature.sign(val, secret);
    }
    if (options.maxAge) {
        options.expires = new Date(Date.now() + options.maxAge);
        options.maxAge /= 1000;
    }
    if (options.path == null) {
        options.path = '/';
    }
    res.setHeader('Set-Cookie', cookie.serialize(name, String(val), options));
    return res;
};
const clearCookie = (req, res) => (name, options) => {
    const opts = Object.assign({}, { expires: new Date(1), path: '/' }, options);
    return setCookie(req, res)(name, '', opts);
};

const charsetRegExp = /;\s*charset\s*=/;
const setHeader = (_req, res) => (field, val) => {
    if (typeof field === 'string') {
        let value = Array.isArray(val) ? val.map(String) : String(val);
        // add charset to content-type
        if (field.toLowerCase() === 'content-type') {
            if (Array.isArray(value)) {
                throw new TypeError('Content-Type cannot be set to an Array');
            }
            if (!charsetRegExp.test(value)) {
                const charset = mime.lookup(value.split(';')[0]);
                if (charset)
                    value += '; charset=' + charset.toLowerCase();
            }
        }
        res.setHeader(field, value);
    }
    else {
        for (const key in field) {
            res.setHeader(key, field[key]);
        }
    }
    return res;
};
const setLocationHeader = (req$1, res) => (url) => {
    let loc = url;
    // "back" is an alias for the referrer
    if (url === 'back') {
        loc = req.getRequestHeader(req$1)('Referrer') || '/';
    }
    // set location
    res.setHeader('Location', loc[0] + encodeURIComponent(loc.slice(1)));
    return res;
};
const getResponseHeader = (_req, res) => (field) => {
    return res.getHeader(field);
};
const setLinksHeader = (req, res) => (links) => {
    let link = res.getHeader('Link') || '';
    if (link)
        link += ', ';
    setHeader(req, res)('Link', link +
        Object.keys(links)
            .map((rel) => '<' + links[rel] + '>; rel="' + rel + '"')
            .join(', '));
    return res;
};
const setVaryHeader = (_req, res) => (field) => {
    esVary.vary(res, field);
    return res;
};
const setContentType = (req, res) => (type) => {
    const ct = type.indexOf('/') === -1 ? mime.lookup(type) : type;
    return setHeader(req, res)('Content-Type', ct);
};

const normalizeType = (type) => {
    return ~type.indexOf('/') ? acceptParams(type) : { value: mime.lookup(type), params: {} };
};
function acceptParams(str, index) {
    const parts = str.split(/ *; */);
    const ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };
    for (const part of parts) {
        const pms = part.split(/ *= */);
        if ('q' === pms[0]) {
            ret.quality = parseFloat(pms[1]);
        }
        else {
            ret.params[pms[0]] = pms[1];
        }
    }
    return ret;
}
function normalizeTypes(types) {
    const ret = [];
    for (const type of types) {
        ret.push(normalizeType(type));
    }
    return ret;
}

const formatResponse = (req$1, res, next) => (obj) => {
    const fn = obj.default;
    if (fn)
        delete obj.default;
    const keys = Object.keys(obj);
    const key = keys.length > 0 ? req.getAccepts(req$1)(...keys) : false;
    setVaryHeader(req$1, res)('Accept');
    if (key) {
        res.setHeader('Content-Type', normalizeType(key).value);
        obj[key](req$1, res, next);
    }
    else if (fn) {
        fn();
    }
    else {
        const err = new Error('Not Acceptable');
        err.status = err.statusCode = 406;
        err.types = normalizeTypes(keys).map((o) => o.value);
        next(err);
    }
    return res;
};

const redirect = (req, res, next) => (url, status) => {
    let address = url;
    status = status || 302;
    let body;
    address = setLocationHeader(req, res)(address).getHeader('Location');
    formatResponse(req, res, next)({
        text: () => {
            body = http.STATUS_CODES[status] + '. Redirecting to ' + address;
        },
        html: () => {
            const u = escapeHtml__default['default'](address);
            body = `<p>${http.STATUS_CODES[status]}. Redirecting to <a href="${u}">${u}</a></p>`;
        },
        default: () => {
            body = '';
        },
    });
    res.setHeader('Content-Length', Buffer.byteLength(body));
    res.statusCode = status;
    if (req.method === 'HEAD') {
        res.end();
    }
    else {
        res.end(body);
    }
    return res;
};

const download = (req, res) => (path$1, filename, options, cb) => {
    let done = cb;
    let name = filename;
    let opts = (options || null);
    // support function as second or third arg
    if (typeof filename === 'function') {
        done = filename;
        name = null;
        opts = null;
    }
    else if (typeof options === 'function') {
        done = options;
        opts = null;
    }
    // set Content-Disposition when file is sent
    const headers = {
        'Content-Disposition': contentDisposition.contentDisposition(name || path$1),
    };
    // merge user-provided headers
    if (opts && opts.headers) {
        for (const key of Object.keys(opts.headers)) {
            if (key.toLowerCase() !== 'content-disposition') {
                headers[key] = opts.headers[key];
            }
        }
    }
    // merge user-provided options
    opts = Object.create(opts);
    opts.headers = headers;
    // Resolve the full path for sendFile
    const fullPath = path.resolve(path$1);
    const noop = () => {
        return;
    };
    // send file
    return send.sendFile(req, res)(fullPath, opts, done || noop);
};
const attachment = (req, res) => (filename) => {
    if (filename) {
        setContentType(req, res)(path.extname(filename));
    }
    setHeader(req, res)('Content-Disposition', contentDisposition.contentDisposition(filename));
    return res;
};

const append = (_req, res) => (field, value) => {
    const prevVal = res.getHeader(field);
    let newVal = value;
    // additional type checks for typescript to not throw errors
    if (prevVal && typeof newVal !== 'number' && typeof prevVal !== 'number') {
        newVal = Array.isArray(prevVal) ? prevVal.concat(newVal) : Array.isArray(newVal) ? [prevVal].concat(newVal) : [prevVal, newVal];
    }
    res.setHeader(field, newVal);
    return res;
};

Object.keys(send).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return send[k];
    }
  });
});
exports.append = append;
exports.attachment = attachment;
exports.clearCookie = clearCookie;
exports.download = download;
exports.formatResponse = formatResponse;
exports.getResponseHeader = getResponseHeader;
exports.redirect = redirect;
exports.setContentType = setContentType;
exports.setCookie = setCookie;
exports.setHeader = setHeader;
exports.setLinksHeader = setLinksHeader;
exports.setLocationHeader = setLocationHeader;
exports.setVaryHeader = setVaryHeader;
