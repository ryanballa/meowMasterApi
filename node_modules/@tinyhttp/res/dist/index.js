import { sendFile } from '@tinyhttp/send';
export * from '@tinyhttp/send';
import { serialize } from '@tinyhttp/cookie';
import { sign } from '@tinyhttp/cookie-signature';
import { lookup } from 'es-mime-types';
import { getRequestHeader, getAccepts } from '@tinyhttp/req';
import { vary } from 'es-vary';
import { STATUS_CODES } from 'http';
import escapeHtml from 'escape-html';
import { contentDisposition } from '@tinyhttp/content-disposition';
import { resolve, extname } from 'path';

const setCookie = (req, res) => (name, value, options = {}) => {
    const secret = req.secret;
    const signed = options.signed || false;
    if (signed && !secret) {
        throw new Error('cookieParser("secret") required for signed cookies');
    }
    let val = typeof value === 'object' ? 'j:' + JSON.stringify(value) : String(value);
    if (signed) {
        val = 's:' + sign(val, secret);
    }
    if (options.maxAge) {
        options.expires = new Date(Date.now() + options.maxAge);
        options.maxAge /= 1000;
    }
    if (options.path == null) {
        options.path = '/';
    }
    res.setHeader('Set-Cookie', serialize(name, String(val), options));
    return res;
};
const clearCookie = (req, res) => (name, options) => {
    const opts = Object.assign({}, { expires: new Date(1), path: '/' }, options);
    return setCookie(req, res)(name, '', opts);
};

const charsetRegExp = /;\s*charset\s*=/;
const setHeader = (_req, res) => (field, val) => {
    if (typeof field === 'string') {
        let value = Array.isArray(val) ? val.map(String) : String(val);
        // add charset to content-type
        if (field.toLowerCase() === 'content-type') {
            if (Array.isArray(value)) {
                throw new TypeError('Content-Type cannot be set to an Array');
            }
            if (!charsetRegExp.test(value)) {
                const charset = lookup(value.split(';')[0]);
                if (charset)
                    value += '; charset=' + charset.toLowerCase();
            }
        }
        res.setHeader(field, value);
    }
    else {
        for (const key in field) {
            res.setHeader(key, field[key]);
        }
    }
    return res;
};
const setLocationHeader = (req, res) => (url) => {
    let loc = url;
    // "back" is an alias for the referrer
    if (url === 'back') {
        loc = getRequestHeader(req)('Referrer') || '/';
    }
    // set location
    res.setHeader('Location', loc[0] + encodeURIComponent(loc.slice(1)));
    return res;
};
const getResponseHeader = (_req, res) => (field) => {
    return res.getHeader(field);
};
const setLinksHeader = (req, res) => (links) => {
    let link = res.getHeader('Link') || '';
    if (link)
        link += ', ';
    setHeader(req, res)('Link', link +
        Object.keys(links)
            .map((rel) => '<' + links[rel] + '>; rel="' + rel + '"')
            .join(', '));
    return res;
};
const setVaryHeader = (_req, res) => (field) => {
    vary(res, field);
    return res;
};
const setContentType = (req, res) => (type) => {
    const ct = type.indexOf('/') === -1 ? lookup(type) : type;
    return setHeader(req, res)('Content-Type', ct);
};

const normalizeType = (type) => {
    return ~type.indexOf('/') ? acceptParams(type) : { value: lookup(type), params: {} };
};
function acceptParams(str, index) {
    const parts = str.split(/ *; */);
    const ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };
    for (const part of parts) {
        const pms = part.split(/ *= */);
        if ('q' === pms[0]) {
            ret.quality = parseFloat(pms[1]);
        }
        else {
            ret.params[pms[0]] = pms[1];
        }
    }
    return ret;
}
function normalizeTypes(types) {
    const ret = [];
    for (const type of types) {
        ret.push(normalizeType(type));
    }
    return ret;
}

const formatResponse = (req, res, next) => (obj) => {
    const fn = obj.default;
    if (fn)
        delete obj.default;
    const keys = Object.keys(obj);
    const key = keys.length > 0 ? getAccepts(req)(...keys) : false;
    setVaryHeader(req, res)('Accept');
    if (key) {
        res.setHeader('Content-Type', normalizeType(key).value);
        obj[key](req, res, next);
    }
    else if (fn) {
        fn();
    }
    else {
        const err = new Error('Not Acceptable');
        err.status = err.statusCode = 406;
        err.types = normalizeTypes(keys).map((o) => o.value);
        next(err);
    }
    return res;
};

const redirect = (req, res, next) => (url, status) => {
    let address = url;
    status = status || 302;
    let body;
    address = setLocationHeader(req, res)(address).getHeader('Location');
    formatResponse(req, res, next)({
        text: () => {
            body = STATUS_CODES[status] + '. Redirecting to ' + address;
        },
        html: () => {
            const u = escapeHtml(address);
            body = `<p>${STATUS_CODES[status]}. Redirecting to <a href="${u}">${u}</a></p>`;
        },
        default: () => {
            body = '';
        },
    });
    res.setHeader('Content-Length', Buffer.byteLength(body));
    res.statusCode = status;
    if (req.method === 'HEAD') {
        res.end();
    }
    else {
        res.end(body);
    }
    return res;
};

const download = (req, res) => (path, filename, options, cb) => {
    let done = cb;
    let name = filename;
    let opts = (options || null);
    // support function as second or third arg
    if (typeof filename === 'function') {
        done = filename;
        name = null;
        opts = null;
    }
    else if (typeof options === 'function') {
        done = options;
        opts = null;
    }
    // set Content-Disposition when file is sent
    const headers = {
        'Content-Disposition': contentDisposition(name || path),
    };
    // merge user-provided headers
    if (opts && opts.headers) {
        for (const key of Object.keys(opts.headers)) {
            if (key.toLowerCase() !== 'content-disposition') {
                headers[key] = opts.headers[key];
            }
        }
    }
    // merge user-provided options
    opts = Object.create(opts);
    opts.headers = headers;
    // Resolve the full path for sendFile
    const fullPath = resolve(path);
    const noop = () => {
        return;
    };
    // send file
    return sendFile(req, res)(fullPath, opts, done || noop);
};
const attachment = (req, res) => (filename) => {
    if (filename) {
        setContentType(req, res)(extname(filename));
    }
    setHeader(req, res)('Content-Disposition', contentDisposition(filename));
    return res;
};

const append = (_req, res) => (field, value) => {
    const prevVal = res.getHeader(field);
    let newVal = value;
    // additional type checks for typescript to not throw errors
    if (prevVal && typeof newVal !== 'number' && typeof prevVal !== 'number') {
        newVal = Array.isArray(prevVal) ? prevVal.concat(newVal) : Array.isArray(newVal) ? [prevVal].concat(newVal) : [prevVal, newVal];
    }
    res.setHeader(field, newVal);
    return res;
};

export { append, attachment, clearCookie, download, formatResponse, getResponseHeader, redirect, setContentType, setCookie, setHeader, setLinksHeader, setLocationHeader, setVaryHeader };
