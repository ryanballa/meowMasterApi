import { format, parse } from 'es-content-type';
import { eTag } from '@tinyhttp/etag';
import { STATUS_CODES } from 'http';
import { createReadStream } from 'fs';
import { isAbsolute, extname } from 'path';
import { contentType } from 'es-mime-types';

/**
 * Respond with stringified JSON object
 * @param _req Request
 * @param res Response
 */
const json = (_req, res) => (body, ...args) => {
    res.setHeader('Content-Type', 'application/json');
    if (typeof body === 'object' && body != null) {
        res.end(JSON.stringify(body, null, 2), ...args);
    }
    else if (typeof body === 'string') {
        res.end(body, ...args);
    }
    return res;
};

const createETag = (body, encoding) => {
    const buf = !Buffer.isBuffer(body) ? Buffer.from(body, encoding) : body;
    return eTag(buf, { weak: true });
};
function setCharset(type, charset) {
    const parsed = parse(type);
    parsed.parameters.charset = charset;
    return format(parsed);
}

/**
 * Sends the HTTP response.
 *
 * The body parameter can be a Buffer object, a string, an object, or an array.
 *
 * This method performs many useful tasks for simple non-streaming responses.
 * For example, it automatically assigns the Content-Length HTTP response header field (unless previously defined) and provides automatic HEAD and HTTP cache freshness support.
 *
 * @param req Request
 * @param res Response
 */
const send = (req, res) => (body) => {
    let bodyToSend = body;
    // in case of object - turn it to json
    if (typeof body === 'object' && body !== null) {
        bodyToSend = JSON.stringify(body, null, 2);
    }
    else {
        if (typeof body === 'string') {
            // reflect this in content-type
            const type = res.getHeader('Content-Type');
            if (type && typeof type === 'string') {
                res.setHeader('Content-Type', setCharset(type, 'utf-8'));
            }
            else {
                res.setHeader('Content-Type', setCharset('text/html', 'utf-8'));
            }
        }
    }
    // Set encoding
    const encoding = 'utf8';
    // populate ETag
    let etag;
    if (body && !res.getHeader('etag') && (etag = createETag(bodyToSend, encoding))) {
        res.setHeader('etag', etag);
    }
    // strip irrelevant headers
    if (res.statusCode === 204 || res.statusCode === 304) {
        res.removeHeader('Content-Type');
        res.removeHeader('Content-Length');
        res.removeHeader('Transfer-Encoding');
        bodyToSend = '';
    }
    if (req.method === 'HEAD') {
        res.end('');
        return;
    }
    if (typeof body === 'object') {
        if (body == null) {
            res.end('');
            return;
        }
        else if (Buffer.isBuffer(body)) {
            if (!res.getHeader('Content-Type')) {
                res.setHeader('content-type', 'application/octet-stream');
            }
        }
        else {
             json(req, res)(bodyToSend, encoding) ;
        }
    }
    else {
        {
            // respond with encoding
            res.end(bodyToSend, encoding);
        }
    }
    return res;
};

/**
 * Sets the response HTTP status code to statusCode and send its string representation as the response body.
 *
 * If an unsupported status code is specified, the HTTP status is still set to statusCode and the string version of the code is sent as the response body.
 *
 * @param _req Request
 * @param res Response
 */
const sendStatus = (_req, res) => (statusCode) => {
    const body = STATUS_CODES[statusCode] || String(statusCode);
    res.statusCode = statusCode;
    res.setHeader('Content-Type', 'text/plain');
    return send(_req, res)(body);
};

/**
 * Sets the HTTP status for the response. It is a chainable alias of Nodeâ€™s `response.statusCode`.
 *
 * @param _req Request
 * @param res Response
 */
const status = (_req, res) => (status) => {
    res.statusCode = status;
    return res;
};

/**
 * Sends a file by piping a stream to response.
 *
 * It also checks for extension to set a proper `Content-Type` header.
 *
 * Path argument must be absolute. To use a relative path, specify the `root` option first.
 *
 * @param _ Request
 * @param res Response
 */
const sendFile = (_, res) => (path, opts, cb) => {
    const { root, headers, ...options } = opts;
    if (!path) {
        if (typeof path !== 'string')
            throw new TypeError('path must be a string to res.sendFile');
        throw new TypeError('path argument is required to res.sendFile');
    }
    if (headers) {
        for (const [k, v] of Object.entries(headers)) {
            res.setHeader(k, v);
        }
    }
    if (!isAbsolute(path))
        throw new TypeError('path must be absolute');
    const stream = createReadStream(root ? root + path : path, options);
    if (cb) {
        stream.on('error', (err) => void cb(err));
        stream.on('end', () => void cb());
    }
    res.setHeader('Content-Type', contentType(extname(path)));
    stream.pipe(res);
    return res;
};

export { json, send, sendFile, sendStatus, status };
