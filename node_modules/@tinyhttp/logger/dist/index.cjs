'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var colorette = require('colorette');
var statusEmoji = require('http-status-emojis');
var dayjs = require('dayjs');
var http = require('http');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var statusEmoji__namespace = /*#__PURE__*/_interopNamespace(statusEmoji);
var dayjs__default = /*#__PURE__*/_interopDefaultLegacy(dayjs);

const joinOutputArgs = (args, req, res, options = {}, status, msg) => {
    var _a, _b;
    const { method, url } = req;
    const { statusCode } = res;
    const methods = (_a = options.methods) !== null && _a !== void 0 ? _a : http.METHODS;
    const timestamp = (_b = options.timestamp) !== null && _b !== void 0 ? _b : false;
    const emojiEnabled = options.emoji;
    if (methods.includes(method)) {
        if (timestamp) {
            if (typeof timestamp !== 'boolean' && timestamp.format) {
                args.push(`${dayjs__default['default']().format(timestamp.format).toString()} - `);
            }
            else {
                args.push(`${dayjs__default['default']().format('HH:mm:ss').toString()} - `);
            }
        }
    }
    if (options.ip)
        args.push(req.ip);
    if (emojiEnabled)
        args.push(statusEmoji__namespace[statusCode]);
    args.push(method);
    args.push(status || res.statusCode);
    args.push(msg || res.statusMessage);
    args.push(url);
};
const logger = (options = {}) => {
    var _a, _b;
    const methods = (_a = options.methods) !== null && _a !== void 0 ? _a : http.METHODS;
    const output = (_b = options.output) !== null && _b !== void 0 ? _b : { callback: console.log, color: true };
    return (req, res, next) => {
        res.on('finish', () => {
            const args = [];
            if (methods.includes(req.method)) {
                const s = res.statusCode.toString();
                if (!output.color) {
                    joinOutputArgs(args, req, res, options);
                    const m = args.join(' ');
                    output.callback(m);
                }
                else {
                    switch (s[0]) {
                        case '2':
                            joinOutputArgs(args, req, res, options, colorette.cyan(colorette.bold(s)), colorette.cyan(res.statusMessage));
                            output.callback(args.join(' '));
                            break;
                        case '4':
                            joinOutputArgs(args, req, res, options, colorette.red(colorette.bold(s)), colorette.red(res.statusMessage));
                            output.callback(args.join(' '));
                            break;
                        case '5':
                            joinOutputArgs(args, req, res, options, colorette.magenta(colorette.bold(s)), colorette.magenta(res.statusMessage));
                            output.callback(args.join(' '));
                            break;
                    }
                }
            }
        });
        next === null || next === void 0 ? void 0 : next();
    };
};

exports.logger = logger;
