import { STATUS_CODES, createServer } from 'http';
import path from 'path';
import { parse } from 'url';
import { compile, proxyaddr, all } from '@tinyhttp/proxy-addr';
import { isIP } from 'net';
import { getRequestHeader, getQueryParams, getFreshOrStale, getRangeFromHeader, getAccepts, getAcceptsCharsets, getAcceptsEncodings, checkIfXMLHttpRequest, matchParams, getURLParams } from '@tinyhttp/req';
export { getURLParams } from '@tinyhttp/req';
import { Router } from '@tinyhttp/router';
import { getResponseHeader, setHeader, send, json, status, sendStatus, sendFile, setContentType, setLocationHeader, setLinksHeader, setVaryHeader, setCookie, clearCookie, formatResponse, redirect, attachment, download, append } from '@tinyhttp/res';

const compileTrust = (val) => {
    if (typeof val === 'function')
        return val;
    if (val === true) {
        // Support plain true/false
        return function () {
            return true;
        };
    }
    if (typeof val === 'number') {
        // Support trusting hop count
        return (_, i) => {
            if (val) {
                return i < val;
            }
        };
    }
    if (typeof val === 'string') {
        // Support comma-separated values
        const vals = val.split(',').map((it) => it.trim());
        return compile(vals);
    }
    return compile(val || []);
};

const getRouteFromApp = (app, handler) => {
    return app.middleware.find((h) => h.handler.name === handler.name);
};
const getProtocol = (req) => {
    const proto = req.connection.encrypted ? 'https' : 'http';
    if (!compileTrust(req.connection.remoteAddress)) {
        return proto;
    }
    const header = req.headers['X-Forwarded-Proto'] || proto;
    const index = header.indexOf(',');
    return index !== -1 ? header.substring(0, index).trim() : header.trim();
};
const getHostname = (req) => {
    let host = req.get('X-Forwarded-Host');
    if (!host || !compileTrust(req.connection.remoteAddress)) {
        host = req.get('Host');
    }
    if (!host)
        return;
    // IPv6 literal support
    const offset = host[0] === '[' ? host.indexOf(']') + 1 : 0;
    const index = host.indexOf(':', offset);
    return index !== -1 ? host.substring(0, index) : host;
};
const getIP = (req) => {
    const proxyFn = compileTrust(req.connection.remoteAddress);
    const ip = proxyaddr(req, proxyFn).replace(/^.*:/, ''); // striping the redundant prefix addeded by OS to IPv4 address
    return ip;
};
const getIPs = (req) => {
    const proxyFn = compileTrust(req.connection.remoteAddress);
    const addrs = all(req, proxyFn);
    return addrs;
};
const getSubdomains = (req, subdomainOffset = 2) => {
    const hostname = getHostname(req);
    if (!hostname)
        return [];
    const offset = subdomainOffset;
    const subdomains = isIP(hostname) ? [hostname] : hostname.split('.').reverse();
    return subdomains.slice(offset);
};

const onErrorHandler = (err, _req, res) => {
    if (!res.writableEnded) {
        const code = (res.statusCode = err.code in STATUS_CODES ? err.code : err.status || 500);
        if (typeof err === 'string' || Buffer.isBuffer(err))
            res.end(err);
        else if (code in STATUS_CODES)
            res.end(STATUS_CODES[code]);
        else
            res.end(err.message);
    }
};

const isAsync = (fn) => fn[Symbol.toStringTag] === 'AsyncFunction';

const renderTemplate = (_req, res, app) => (file, data, options) => {
    app.render(file, data, (err, html) => {
        if (err)
            throw err;
        res.send(html);
    }, options);
    return res;
};

/**
 * Extends Request and Response objects with custom properties and methods
 * @param options App settings
 */
const extendMiddleware = (app) => (req, res, next) => {
    const options = app.settings;
    /// Define extensions
    req.originalUrl = req.url;
    res.get = getResponseHeader(req, res);
    req.get = getRequestHeader(req);
    /**
      Bind `app` to `req` / `res`
     */
    if (options === null || options === void 0 ? void 0 : options.bindAppToReqRes) {
        req.app = app;
        res.app = app;
    }
    /*
    Request extensions
    */
    if (options === null || options === void 0 ? void 0 : options.networkExtensions) {
        const proto = getProtocol(req);
        const secure = proto === 'https';
        req.protocol = proto;
        req.secure = secure;
        req.connection = Object.assign(req.socket, {
            encrypted: secure,
        });
        req.hostname = getHostname(req);
        req.subdomains = getSubdomains(req, options.subdomainOffset);
        req.ip = getIP(req);
        req.ips = getIPs(req);
    }
    req.query = getQueryParams(req.url);
    if (options === null || options === void 0 ? void 0 : options.freshnessTesting) {
        req.fresh = getFreshOrStale(req, res);
        req.stale = !req.fresh;
    }
    req.range = getRangeFromHeader(req);
    req.accepts = getAccepts(req);
    req.acceptsCharsets = getAcceptsCharsets(req);
    req.acceptsEncodings = getAcceptsEncodings(req);
    req.xhr = checkIfXMLHttpRequest(req);
    /*
    Response extensions
    */
    res.header = res.set = setHeader(req, res);
    res.send = send(req, res);
    res.json = json(req, res);
    res.status = status(req, res);
    res.sendStatus = sendStatus(req, res);
    res.sendFile = sendFile(req, res);
    res.type = setContentType(req, res);
    res.location = setLocationHeader(req, res);
    res.links = setLinksHeader(req, res);
    res.vary = setVaryHeader(req, res);
    res.cookie = setCookie(req, res);
    res.clearCookie = clearCookie(req, res);
    res.render = renderTemplate(req, res, app);
    res.format = formatResponse(req, res, next);
    res.redirect = redirect(req, res, next);
    res.attachment = attachment(req, res);
    res.download = download(req, res);
    res.append = append(req, res);
    res.locals = res.locals || Object.create(null);
};

const applyHandler = (h) => async (req, res, next) => {
    if (isAsync(h)) {
        await h(req, res, next);
    }
    else {
        h(req, res, next);
    }
};
/**
 * `App` class - the starting point of tinyhttp app.
 *
 * With the `App` you can:
 * * use routing methods and `.use(...)`
 * * set no match (404) and error (500) handlers
 * * configure template engines
 * * store data in locals
 * * listen the http server on a specified port
 *
 * In case you use TypeScript, you can pass custom types to this class because it is also a generic class.
 *
 * The first generic argument is template engine options type, usually taken from engine typings.
 *
 * First and third are `Request` and `Response` objects, respectively. Both extend the tinyhttp's `Request` and `Response` so you can add custom properties without pain.
 *
 * Example:
 *
 * ```ts
 * interface CoolReq extends Request {
 *  genericsAreDope: boolean
 * }
 *
 * const app = App<any, CoolReq, Response>()
 * ```
 */
class App extends Router {
    constructor(options = {}) {
        super();
        this.middleware = [];
        this.locals = {};
        this.settings = {};
        this.engines = {};
        this.onError = (options === null || options === void 0 ? void 0 : options.onError) || onErrorHandler;
        this.noMatchHandler = (options === null || options === void 0 ? void 0 : options.noMatchHandler) || this.onError.bind(null, { code: 404 });
        this.settings = options.settings;
    }
    /**
     * Set app setting
     * @param setting setting name
     * @param value setting value
     */
    set(setting, value) {
        this.settings[setting] = value;
    }
    /**
     * Enable app setting
     * @param setting Setting name
     */
    enable(setting) {
        this.settings[setting] = true;
    }
    /**
     * Disable app setting
     * @param setting
     */
    disable(setting) {
        this.settings[setting] = false;
    }
    /**
     * Render a template
     * @param file What to render
     * @param data data that is passed to a template
     * @param options Template engine options
     * @param cb Callback that consumes error and html
     */
    render(file, data = {}, cb, options = {}) {
        options.viewsFolder = options.viewsFolder || `${process.cwd()}/views`;
        options.ext = options.ext || file.slice(file.lastIndexOf('.') + 1) || 'ejs';
        options._locals = options._locals || {};
        options.cache = options.cache || process.env.NODE_ENV === 'production';
        let locals = { ...data, ...this.locals };
        if (options._locals)
            locals = { ...locals, ...options._locals };
        if (typeof file !== 'string')
            throw new Error('File must be a string.');
        if (!file.endsWith(`.${options.ext}`))
            file = file + `.${options.ext}`;
        const dest = options.viewsFolder ? path.join(options.viewsFolder, file) : file;
        const engine = this.engines[options.ext];
        const result = engine(dest, locals, options.renderOptions, cb);
        return result;
    }
    /**
     * Register a template engine with extension
     */
    engine(ext, fn) {
        if (typeof fn !== 'function') {
            throw new Error('callback function required');
        }
        this.engines[ext] = fn;
        return this;
    }
    /**
     * Extends Req / Res objects, pushes 404 and 500 handlers, dispatches middleware
     * @param req Req object
     * @param res Res object
     */
    async handler(req, res) {
        var _a;
        /* Set X-Powered-By header */
        if ((_a = this.settings) === null || _a === void 0 ? void 0 : _a.xPoweredBy)
            res.setHeader('X-Powered-By', 'tinyhttp');
        const mw = this.middleware;
        const subappPath = Object.keys(this.apps).find((x) => req.url.startsWith(x));
        if (subappPath) {
            const app = this.apps[subappPath];
            app.handler(req, res);
        }
        const noMatchMW = {
            handler: this.noMatchHandler,
            type: 'mw',
            path: '/',
        };
        mw.push(noMatchMW);
        let idx = 0;
        const len = mw.length - 1;
        const nextWithReqAndRes = (req, res) => (err) => {
            if (err) {
                this.onError(err, req, res);
            }
            else {
                loop(req, res);
            }
        };
        const handle = (mw) => async (req, res, next) => {
            const { path, method, handler, type } = mw;
            extendMiddleware(this)(req, res, next);
            const parsedUrl = parse(req.url);
            req.path = parsedUrl.pathname;
            if (type === 'route') {
                if (req.method === method) {
                    // strip query parameters for req.params
                    if (matchParams(path, parsedUrl.pathname)) {
                        req.params = getURLParams(req.url, path);
                        req.route = getRouteFromApp(this, handler);
                        // route found, send Success 200
                        res.statusCode = 200;
                        await applyHandler(handler)(req, res, next);
                    }
                    else {
                        loop(req, res);
                    }
                }
                else {
                    loop(req, res);
                }
            }
            else {
                if (req.url.startsWith(path)) {
                    await applyHandler(handler)(req, res, next);
                }
                else {
                    loop(req, res);
                }
            }
        };
        const loop = (req, res) => {
            if (res.writableEnded)
                return;
            else if (idx <= len) {
                handle(mw[idx++])(req, res, nextWithReqAndRes(req, res));
            }
            else {
                return;
            }
        };
        loop(req, res);
    }
    /**
     * Creates HTTP server and dispatches middleware
     * @param port server listening port
     * @param Server callback after server starts listening
     * @param host server listening host
     */
    listen(port, cb, host = '0.0.0.0') {
        const server = createServer();
        server.on('request', (req, res) => this.handler(req, res));
        return server.listen(port, host, cb);
    }
}

export { App, applyHandler, extendMiddleware, getHostname, getIP, getIPs, getProtocol, getRouteFromApp, getSubdomains, renderTemplate };
