/// <reference types="node" />
import type { Request } from './request';
import type { Response } from './response';
import type { ErrorHandler } from './onError';
import { Middleware, Handler, NextFunction, Router } from '@tinyhttp/router';
export declare const applyHandler: (h: Handler) => (req: Request, res: Response, next?: NextFunction) => Promise<void>;
/**
 * tinyhttp App has a few settings for toggling features
 */
export declare type AppSettings = Partial<{
    networkExtensions: boolean;
    freshnessTesting: boolean;
    subdomainOffset: number;
    bindAppToReqRes: boolean;
    xPoweredBy: boolean;
}>;
/**
 * Function that processes the template
 */
export declare type TemplateFunc<O> = (path: string, locals: Record<string, any>, opts: TemplateEngineOptions<O>, cb: (err: Error, html: unknown) => void) => void;
export declare type TemplateEngineOptions<O = any> = Partial<{
    cache: boolean;
    ext: string;
    renderOptions: O;
    viewsFolder: string;
    _locals: Record<string, any>;
}> & Record<string, any>;
/**
 * `App` class - the starting point of tinyhttp app.
 *
 * With the `App` you can:
 * * use routing methods and `.use(...)`
 * * set no match (404) and error (500) handlers
 * * configure template engines
 * * store data in locals
 * * listen the http server on a specified port
 *
 * In case you use TypeScript, you can pass custom types to this class because it is also a generic class.
 *
 * The first generic argument is template engine options type, usually taken from engine typings.
 *
 * First and third are `Request` and `Response` objects, respectively. Both extend the tinyhttp's `Request` and `Response` so you can add custom properties without pain.
 *
 * Example:
 *
 * ```ts
 * interface CoolReq extends Request {
 *  genericsAreDope: boolean
 * }
 *
 * const app = App<any, CoolReq, Response>()
 * ```
 */
export declare class App<RenderOptions = any, Req extends Request = Request, Res extends Response = Response> extends Router<App, Request, Response> {
    middleware: Middleware[];
    locals: Record<string, string>;
    noMatchHandler: Handler;
    onError: ErrorHandler;
    settings: AppSettings;
    engines: Record<string, TemplateFunc<RenderOptions>>;
    constructor(options?: Partial<{
        noMatchHandler: Handler<Req, Res>;
        onError: ErrorHandler;
        settings: AppSettings;
    }>);
    /**
     * Set app setting
     * @param setting setting name
     * @param value setting value
     */
    set(setting: string, value: any): void;
    /**
     * Enable app setting
     * @param setting Setting name
     */
    enable(setting: string): void;
    /**
     * Disable app setting
     * @param setting
     */
    disable(setting: string): void;
    /**
     * Render a template
     * @param file What to render
     * @param data data that is passed to a template
     * @param options Template engine options
     * @param cb Callback that consumes error and html
     */
    render(file: string, data: Record<string, any>, cb: (err: unknown, html: unknown) => void, options?: TemplateEngineOptions<RenderOptions>): void;
    /**
     * Register a template engine with extension
     */
    engine(ext: string, fn: TemplateFunc<RenderOptions>): this;
    /**
     * Extends Req / Res objects, pushes 404 and 500 handlers, dispatches middleware
     * @param req Req object
     * @param res Res object
     */
    handler(req: Req, res: Res): Promise<void>;
    /**
     * Creates HTTP server and dispatches middleware
     * @param port server listening port
     * @param Server callback after server starts listening
     * @param host server listening host
     */
    listen(port?: number, cb?: () => void, host?: string): import("http").Server;
}
